#!/usr/bin/env python
# coding: utf-8

# In[ ]:


import math
import random
import fractions

def phi(n):
    amount = 0
    for k in range(1, n + 1):
        if math.gcd(n, k) == 1:
            amount += 1
    return amount

def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y

def modinv(a, m):
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m
    
lowercase = {'a':0, 'b':1, 'c':2, 'd':3, 'e':4, 'f':5, 'g':6, 'h':7, 'i':8,
         'j':9, 'k':10, 'l':11, 'm':12, 'n':13, 'o':14, 'p':15, 'q':16,
         'r':17, 's':18,  't':19, 'u':20, 'v':21, 'w':22, 'x':23, 'y':24,
         'z':25}

uppercase ={'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7, 'I':8,
         'J':9, 'K':10, 'L':11, 'M':12, 'N':13, 'O':14, 'P':15, 'Q':16,
         'R':17, 'S':18,  'T':19, 'U':20, 'V':21, 'W':22, 'X':23, 'Y':24,
         'Z':25}

inv_lowercase = {0:'a', 1:'b', 2:'c', 3:'d', 4:'e', 5:'f', 6:'g', 7:'h', 8:'i',
         9:'j', 10:'k', 11:'l', 12:'m', 13:'n', 14:'o', 15:'p', 16:'q',
         17:'r', 18:'s', 19:'t', 20:'u', 21:'v', 22:'w', 23:'x', 24:'y',
         25:'z'}

inv_uppercase = {0:'A', 1:'B', 2:'C', 3:'D', 4:'E', 5:'F', 6:'G', 7:'H',
                 8:'I', 9:'J', 10:'K', 11:'L', 12:'M', 13:'N', 14:'O', 15:'P',
                 16:'Q', 17:'R', 18:'S', 19:'T', 20:'U', 21:'V', 22:'W', 23:'X',
                 24:'Y', 25:'Z'}

letter_count = {'A':0, 'B':0, 'C':0, 'D':0, 'E':0, 'F':0, 'G':0, 'H':0, 'I':0,
         'J':0, 'K':0, 'L':0, 'M':0, 'N':0, 'O':0, 'P':0, 'Q':0,
         'R':0, 'S':0,  'T':0, 'U':0, 'V':0, 'W':0, 'X':0, 'Y':0, 'Z':0}

def Affine_Dec(ptext, key):
    plen = len(ptext)
    ctext = ''
    for i in range (0,plen):
        letter = ptext[i]
        if letter in lowercase:
            poz = lowercase[letter]
            poz = (key.gamma*poz+key.theta)%26
            #print poz
            ctext += inv_lowercase[poz]
        elif letter in uppercase:
            poz = uppercase[letter]
            poz = (key.gamma*poz+key.theta)%26
            ctext += inv_uppercase[poz]
        else:
            ctext += ptext[i]
    return ctext


def Affine_Enc(ptext, key):
    plen = len(ptext)
    ctext = ''
    for i in range (0,plen):
        letter = ptext[i]
        if letter in lowercase:
            poz = lowercase[letter]
            poz = (key.alpha*poz+key.beta)%26
            #print poz
            ctext += inv_lowercase[poz]
        elif letter in uppercase:
            poz = uppercase[letter]
            poz = (key.alpha*poz+key.beta)%26
            ctext += inv_uppercase[poz]
        else:
            ctext += ptext[i]
    return ctext


class key(object):
    alpha=0
    beta=0
    gamma=0
    theta=0


# In[ ]:


####################### QUESTION 1 ###########################

#1.	(20 pts) Consider the shift cipher. Show that the ciphertext “NZWO” can be decrypted into two meaningful English words. 
#Find out those words and the corresponding encryption keys

def caesarDecrypt(text, s): 
    result = "" 
    # traverse text 
    for letter in range(len(text)): 
        char = text[letter] 
        # Encrypt uppercase characters 
        if (char.isupper()): 
            result += chr((ord(char) - s-65) % 26 + 65) 
  
        # Encrypt lowercase characters 
        else: 
            result += chr((ord(char) - s - 97) % 26 + 97) 
  
    return result 

caesarCiphertext = "NZWO"
wordList = []

for i in range(1,26):
    wordList.append((caesarDecrypt(caesarCiphertext, i)))
    
print(wordList)


# In[ ]:


####################### QUESTION 2 ###########################

#Consider the ciphertext generated by Affine Cipher over Z26. As a hint, you are told that the most frequent letter in the 
#plaintext is “A”. Find the plaintext and the encryption keys

from fractions import gcd

gcdList = []

for i in range(1,26):
    if math.gcd(i,26) == 1:
        gcdList.append(i)


# In[ ]:


from collections import Counter 

affineCiphertext= "H fzbbvffsza xhu jf ruv tmr bhu ahn h sjix srzuyhcjru tjcm cmv eijbdf rcmvif mhwv cmirtu hc mjx."

res = Counter(affineCiphertext)
print("Count of all characters in Ciphertext is: \n"+  str(res))


# In[ ]:


betaList = list(range(0,26))
possibleKey = []
invGcd =[]

for i in gcdList:
    invGcd.append(modinv(i, 26))

k1 = key()

for i in invGcd:
    for j in betaList:
        k1.gamma = i
        k1.theta = j
        possibleKey.append(Affine_Dec(affineCiphertext, k1))   


# In[ ]:


st = "successful"
for i in range(0,len(possibleKey)):
    if st in possibleKey[i]:
        print("It is at index ", i, "\n and the sentence is: ", possibleKey[i])


# In[ ]:


####################### QUESTION 3 ###########################


bigramLetters = {'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7, 'I':8, 'J':9, 'K':10, 'L':11, 'M':12, 'N':13, 'O':14,
                 'P':15, 'Q':16, 'R':17, 'S':18, 'T':19, 'U':20, 'V':21, 'W':22, 'X':23, 'Y':24, 'Z':25,     
                 ' ':26, '.':27, ',': 28, '!': 29, '?':30}

inv_bigramLetters = {0:'A', 1:'B', 2:'C', 3:'D', 4:'E', 5:'F', 6:'G', 7:'H',
                 8:'I', 9:'J', 10:'K', 11:'L', 12:'M', 13:'N', 14:'O', 15:'P',
                 16:'Q', 17:'R', 18:'S', 19:'T', 20:'U', 21:'V', 22:'W', 23:'X',
                 24:'Y', 25:'Z',  26:' ',  27:'.',  28:',',  29:'!',  30:'?'}


# In[ ]:


phi(961)


# In[ ]:


bigramGcd = []
noOfLetters = 31*31
bigramBeta = list(range(0, noOfLetters + 1))

for i in range(1, 961):
    if math.gcd(i,961) == 1:
        bigramGcd.append(i)

biInvGcd =[]
for i in bigramGcd:
    biInvGcd.append(modinv(i, 26))

print("The number of possible gcd of alpha and number of unique bigram letters:",len(biInvGcd))
print("All possible beta values are between 0 and 961")
print("Key space is ", len(biInvGcd), " * 961 = ", 930* len(biInvGcd))


# In[ ]:


####################### QUESTION 4 ###########################

def affine_bigram(string, k1, k2):
    mod = (31 * 31)

    result = ""
    i = 0
    while (i < len(string) - 1):
        result += invAlphabet[(k1 * alphabets[(string[i] + string[i + 1])] + k2) % mod]
        i += 2
    return result

let = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',          'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', '.',          ',', '!', '?']

alphabets = {}
invAlphabet = {}
count = 0
for i in range(len(let)):
    for j in range(len(let)):
        alphabets[let[i]+let[j]] = count
        count += 1

invAlphabet = {v: k for k, v in alphabets.items()}


# In[ ]:


possibleTexts = []

textToDec = "? RCYYP FYYK?VISYY?.J,HGQL?. ,HU!O,HXVBKMBRY??EPYT"

for i in range(0, 961, 1):
    for j in range(0, 961, 1):
        possibleTexts.append((affine_bigram(textToDec, j, i)))


# In[ ]:


narrowed =[]
for k in range(0, len(possibleTexts), 1):
    txt = possibleTexts[k]
    if txt.endswith('.') or txt.endswith('!') or txt.endswith('?'):
        narrowed.append(txt)
    
print(len(narrowed))


# In[ ]:


narrowedMore=[]
subBigram = "THOSE"
for i in range(0, len(narrowed), 1):
    t = narrowed[i]
    if "THOSE" in t:
        print(t)
    else:
        continue


# In[ ]:


####################### QUESTION 5 ###########################

def vigDec(text, key):
    keyLen = len(key)
    plain = ""
    poz=[]
    for i in range (0, len(key)):
        let = key[i]
        if let in uppercase:
            poz.append(uppercase[let])
    
    index = 0
    for letter in range(len(text)):
        char = text[letter]
        if char != ' ' and (char.isupper()):
            plain += chr((ord(char) - poz[index%6] -65 ) %26 +65)
            index +=1 
        else:
            plain += text[letter]
    return plain


# In[ ]:


vigText = "A RRNNQW TB IGQOEE BAYL QHMLRAOA WG RZE TZHSFDF BAYL I QWG’R CNBE MFW AAAPCJ. "

vigKey = "SANITY"
vigLen = len(vigKey)
vigVec = []

poz = []
for i in range (0, len(vigKey)):
    let = vigKey[i]
    if let in uppercase:
        poz.append(uppercase[let])

print(poz)


# In[ ]:


vigDec(vigText,vigKey)


# In[ ]:


textToDec = "Gsoom onyos ppwro lra Q lgsyk E sfng. Sio pgtcp io qf srp vetdzqp, tdwmfr;Se sqdk xzt omw lo dtkxhhxr hazwSy hapkz gsd wkwvr ptlh ch vseh ovgv.Wj leblko sonaw ledt ppamu tt mcwdb Eo obgo gttdwms k qanuznede jmsq Lptsmwm dse swgcc lnz njnjpn hicd Dse zijjodt adwmsyg kn lgo jewz. Zd qtvaa zhc sanvwrc mehtk z csagm Ln kdk en lgoce ea knwp mealzup. Tdm gmvj oppwq czujl'k srp ssmwo Yq ewaq vsyd wvv cyhnu ndzup. Tdm onyos wzw kygehg, vzbv ajl vdoa, Bqb A gkge lzglsdeo bg jopp, Wvv lsweo bg fy mebwjd S dlamh, Zxo metwr dz gk jweyce E addoa."


# In[ ]:


from collections import Counter 

res = Counter(textToDec) 
del res[' '] 
print ("Count of all characters in text is :\n "
                                           +  str(res)) 


# In[ ]:


####################### QUESTION 6 ###########################

def caesarDec(text, s): 
    result = "" 
    # traverse text 
    for letter in range(len(text)): 
        char = text[letter] 
        # Encrypt uppercase characters 
        if char != ' ':
            if (char.isupper()): 
                result += chr((ord(char) - s-65) % 26 + 65) 
            else: 
                result += chr((ord(char) - s - 97) % 26 + 97) 
        else:
            result += char
    return result 



counter=[]
for i in range(1, 31):
    tx = caesarDec(textToDec, i)
    a=list(set(tx)&set(textToDec))
    print("For shift ", i, ": ", len(a))
    
    #counter.append(ct)
    #print("For shift of ", i, " it is :", counter[i])

    

