# -*- coding: utf-8 -*-
"""DS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q-dLj3kMdmqr63zm22jD0JL-XVbJk_eg
"""

!pip install pyprimes
!pip install cryptohash
!pip install pycryptodome


import random
import pyprimes
import warnings
from Crypto.Hash import SHA3_256
from Crypto.Hash import SHAKE128
import math
import string
import warnings
import pyprimes
import sympy
import os.path
import sys
import string
import Tx

def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y

def modinv(a, m):
    if a < 0:
        a = a+m
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m
    
def random_prime(bitsize):
    warnings.simplefilter('ignore')
    chck = False
    while chck == False:
        p = random.randrange(2**(bitsize-1), 2**bitsize-1)
        chck = pyprimes.isprime(p)
    warnings.simplefilter('default')    
    return p

def large_DL_Prime(q, bitsize):
    warnings.simplefilter('ignore')
    chck = False
    while chck == False:
        k = random.randrange(2**(bitsize-1), 2**bitsize-1)
        p = k*q+1
        chck = pyprimes.isprime(p)
    warnings.simplefilter('default')    
    return p

def Public_Param_Generator(qsize, psize):
    q = random_prime(qsize)
    p = large_DL_Prime(q, psize-qsize)
    tmp = (p-1)//q
    g = 1
    while g == 1:
        alpha = random.randrange(1, p)
        g = pow(alpha, tmp, p)
    return q, p, g

# Key generation: A user picks a random secret key 0 < α < q−1 and computes the public key β = gα mod p. 

def KeyGen(q,p,g):
  a = random.randrange(1, q-2)
  #random function is inclusive, meaning we cannot include 0
  beta = pow(g,a,p)
  return a, beta 

 #(s, r) = SignGen(message, q, p, g, alpha)
 #return SignVer(message, s, r, q, p, g, beta)


def SignGen(m,q,p,g,a):
  #h_obj = SHA3_256.new(int.from_bytes(m, byteorder='big'))
  #h_obj.update(int.from_bytes(m, byteorder='big'))
  #h = int.from_bytes(h_obj.digest(), byteorder='big') %q
  #shake = SHA3_256.new(m)
  #h = int.from_bytes(shake.digest(), byteorder='big') % q

  h_obj = SHA3_256.new()
  h_obj.update(m)
  h = int.from_bytes(h_obj.digest(), byteorder='big') % q
  k = random.randrange(1, q-1)
  r= pow(g,k,p) % q
  s= (a*r - k*h) %q
  return s,r 


def SignVer(m,s,r,q,p,g,b):
  #h_obj = SHA3_256.new(int.from_bytes(m, byteorder='big'))
  #h = int.from_bytes(h_obj.digest(), byteorder='big') %q
  #shake = SHA3_256.new(m)

  h_obj = SHA3_256.new()
  h_obj.update(m)
  h = int.from_bytes(h_obj.digest(), byteorder='big') % q

  #h = int.from_bytes(shake.digest(), byteorder='big') % q
  v = modinv(h,q)
  z1 = s*v %q
  z2=r*v %q
  u = ( (pow(g,-z1+p-1, p) * pow(b, z2, p) )%p )%q
  #u = ((pow(modinv(g,p), z1, p) * pow(b,z2,p)%p)) % q
  
  if u==r:
    return 0
  else:
    return 1

# Generate or read the public parameters
# You need to have a routine named GenerateOrRead that reads q, p, g from "pubparams.txt" if exists
# Otherwise, it should generate public parameters and write them to "pubparams.txt" 
def GenerateOrRead(fileName):
  try:
    with open(fileName, 'r') as file:
      q=int(file.readline())
      p=int(file.readline())
      g=int(file.readline())
  except:
    f= open("pubparams.txt","w+")
    q,p,g = Public_Param_Generator(224, 2048)
    f.write(str(q)+"\n")
    f.write(str(p)+"\n")
    f.write(str(g)+"\n")

  return q,p,g

def random_string(size):
  """Generate a random string of fixed length """
  letters = string.ascii_letters
  return ''.join(random.choice(letters) for i in range(size))
#checkDSparams(q,p,g) takes your public parameters (q,p,g) and checks if they are correct. It returns 0 
#if they are. Otherwise, it returns a code that indicates the problem.